#requires -version 4.0
#requires -module PKI

#get machine cert thumbprint and export certificate
Function Export-MachineCertificate {

<#
.SYNOPSIS
Export the most current machine certificate.

.DESCRIPTION
This command uses PowerShell remoting to connect to a computer and get the most recent and unexpired certificate that is configured for server authentication. The certificate will be exported to the specified path if it can be verified using Test-Certificate.

The command will also write a custom object to the pipeline that includes the certificate thumbprint. You might want to use this command when creating DSC resources that require certificates.

.PARAMETER Path
The path to the folder where certificates will be stored. The exported files will use the format <computername>.cer. See examples.

.PARAMETER Authentication
Specifies the mechanism that is used to authenticate the user's credentials.   Valid values are Default, Basic, Credssp, Digest, Kerberos, Negotiate, and NegotiateWithImplicitCredential.  The default value is Default.
CredSSP authentication is available only in Windows Vista, Windows Server 2008, and later versions of Windows.
For information about the values of this parameter, see the description of the System.Management.Automation.Runspaces.AuthenticationMechanism enumeration in MSDN.
CAUTION: Credential Security Support Provider (CredSSP) authentication, in which the user's credentials are passed to a remote computer to be authenticated, is designed for commands that require authentication on more than one resource, such as accessing a remote network share. This mechanism increases the security risk of the remote operation. If the remote computer is compromised, the credentials that are passed to it can be used to control the network session.

.PARAMETER CertificateThumbprint
Specifies the digital public key certificate (X509) of a user account that has permission to perform this action. Enter the certificate thumbprint of the certificate.
Certificates are used in client certificate-based authentication. They can only be mapped to local user accounts; they do not work with domain accounts.
To get a certificate, use the Get-Item or Get-ChildItem commands in the Windows PowerShell Cert: drive.

.PARAMETER Credential
Specifies a user account that has permission to perform this action. The default is the current user.
Type a user name, such as "User01" or "Domain01\User01", or enter a variable that contains a PSCredential object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.

.PARAMETER Port
Specifies the network port  on the remote computer used for this command. To connect to a remote computer, the remote computer must be listening on the port that the connection uses.  The default ports are 5985 (the WinRM port for HTTP) and 5986 (the WinRM port for HTTPS).
Before using an alternate port, configure the WinRM listener on the remote computer to listen at that port. To configure the listener, type the following two commands at the Windows PowerShell prompt:

Remove-Item -Path WSMan:\Localhost\listener\listener* -Recurse

New-Item -Path WSMan:\Localhost\listener -Transport http -Address * -Port <port-number>

Do not use the Port parameter unless you must. The port that is set in the command applies to all computers or sessions on which the command runs. An alternate port setting might prevent the command from running on all computers.

.PARAMETER UseSSL
Uses the Secure Sockets Layer (SSL) protocol to establish a connection to the remote computer. By default, SSL is not used.
WS-Management encrypts all Windows PowerShell content transmitted over the network. UseSSL is an additional protection that sends the data across an HTTPS, instead of HTTP.
If you use this parameter, but SSL is not available on the port used for the command, the command fails.

.PARAMETER SkipTest
Export the certificate if possible but don't test it.

.EXAMPLE
PS C:\>Export-MachineCertificate chi-web02 | format-list


Computername : chi-web02
Subject      : CN=CHI-WEB02.GLOBOMANTICS.local
Thumbprint   : EEA8BBA6B3EE6CF00FB2110FF6D4A5A716291C64
Path         : C:\Certs\chi-web02.cer
Verfied      : True

.Link
Test-Certificate
Export-Certificate
#>

[cmdletbinding()]
Param(
[Parameter(Position=0,ValueFromPipeline,ValueFromPipelineByPropertyName)]
[ValidateNotNullorEmpty()]
[Alias("cn")]
[string[]]$Computername = $env:COMPUTERNAME,
[ValidateScript({Test-Path $_})]
[string]$Path = "C:\Certs",
[Alias("RunAs")]
[PSCredential]
[System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
[ValidateRange(1, 65535)]
[int]$Port,
[switch]$UseSSL,
[System.Management.Automation.Runspaces.AuthenticationMechanism]$Authentication,
[string]$CertificateThumbprint,
[switch]$SkipTest
)

Begin {
    Write-Verbose "Starting: $($MyInvocation.Mycommand)"  
    #define a scriptblock to get certificates with Invoke-Command
    $get = {
     #get server authentication certs that have not expired
     #and get newest one
     Get-ChildItem -path Cert:\LocalMachine\My | 
     Where-Object {$_.EnhancedKeyUsageList.FriendlyName -contains "Server Authentication" -AND $_.notAfter -gt (Get-Date) } |
     Sort-Object NotBefore -Descending | Select-Object -first 1
    }

    #remove Path and SkipTest from PSBoundparameters which can then be splatted to Invoke-Command
    $PSBoundParameters.Remove("Path") | Out-Null
    $PSBoundParameters.Remove("SkipTest") | Out-Null

    #add ErrorAction
    $PSBoundParameters.Add("ErrorAction","Stop")

    #add scriptblock
    $PSBoundParameters.Add("Scriptblock",$get)

    Write-Verbose "PSBoundParameters `n $(($PSBoundParameters | Out-String).Trim())"
    
} #begin


Process {

foreach ($computer in $Computername) {
    $PSBoundParameters.Computername = $Computer
    Try {
        #assumes a single certificate so sort on NotAfter
        Write-Verbose "Querying $computer for Machine certificates"
        $cert = Invoke-Command @PSBoundParameters
        Write-Verbose ($cert | Out-String).Trim()
    }
    Catch {
        Throw $_
    }

    if ($cert) {

       $exportPath  = Join-path -Path $Path -ChildPath "$($cert.pscomputername).cer"
       $Verified = $False 
       Write-Verbose "Exporting certificate for $($cert.subject.trim()) to $exportpath"
       #create a custom object
        $obj = [pscustomobject]@{
         Computername = $cert.pscomputername
         Subject = $cert.Subject
         Thumbprint = $cert.Thumbprint
         Path = Export-Certificate -Cert $cert -FilePath $exportPath
        }

       if ($SkipTest) {
        Write-Verbose "Skipping certificate validation"
        $Verified = $False
       }
       Else {
        Write-Verbose "Testing certificate"
        $Verified = Test-Certificate $cert  
        } 
              
        #add Verified to Object
        Write-Verbose "Updating object"
        $obj | Add-Member -MemberType NoteProperty -Name Verified -Value $Verified -PassThru

    } #if $cert
     else {
        Write-Warning "Failed to find a certificate for $($computer.toUpper())"
     }
} #foreach computer

} #process

End {
    Write-Verbose "Ending: $($MyInvocation.Mycommand)"
} #end

} #Export-MachineCertificate

Function Get-MachineCertificateThumbprint {

<#
.SYNOPSIS
Get information about the most current machine certificate.

.DESCRIPTION
This command uses PowerShell remoting to connect to a computer and get the most recent and unexpired certificate that is configured for server authentication. The command will write a custom object to the pipeline that includes the certificate thumbprint. You might want to use this command when creating DSC resources that require certificates.

.PARAMETER Authentication
Specifies the mechanism that is used to authenticate the user's credentials.   Valid values are Default, Basic, Credssp, Digest, Kerberos, Negotiate, and NegotiateWithImplicitCredential.  The default value is Default.
CredSSP authentication is available only in Windows Vista, Windows Server 2008, and later versions of Windows.
For information about the values of this parameter, see the description of the System.Management.Automation.Runspaces.AuthenticationMechanism enumeration in MSDN.
CAUTION: Credential Security Support Provider (CredSSP) authentication, in which the user's credentials are passed to a remote computer to be authenticated, is designed for commands that require authentication on more than one resource, such as accessing a remote network share. This mechanism increases the security risk of the remote operation. If the remote computer is compromised, the credentials that are passed to it can be used to control the network session.

.PARAMETER CertificateThumbprint
Specifies the digital public key certificate (X509) of a user account that has permission to perform this action. Enter the certificate thumbprint of the certificate.
Certificates are used in client certificate-based authentication. They can only be mapped to local user accounts; they do not work with domain accounts.
To get a certificate, use the Get-Item or Get-ChildItem commands in the Windows PowerShell Cert: drive.

.PARAMETER Credential
Specifies a user account that has permission to perform this action. The default is the current user.
Type a user name, such as "User01" or "Domain01\User01", or enter a variable that contains a PSCredential object, such as one generated by the Get-Credential cmdlet. When you type a user name, you will be prompted for a password.

.PARAMETER Port
Specifies the network port  on the remote computer used for this command. To connect to a remote computer, the remote computer must be listening on the port that the connection uses.  The default ports are 5985 (the WinRM port for HTTP) and 5986 (the WinRM port for HTTPS).
Before using an alternate port, configure the WinRM listener on the remote computer to listen at that port. To configure the listener, type the following two commands at the Windows PowerShell prompt:

Remove-Item -Path WSMan:\Localhost\listener\listener* -Recurse

New-Item -Path WSMan:\Localhost\listener -Transport http -Address * -Port <port-number>

Do not use the Port parameter unless you must. The port that is set in the command applies to all computers or sessions on which the command runs. An alternate port setting might prevent the command from running on all computers.

.PARAMETER UseSSL
Uses the Secure Sockets Layer (SSL) protocol to establish a connection to the remote computer. By default, SSL is not used.
WS-Management encrypts all Windows PowerShell content transmitted over the network. UseSSL is an additional protection that sends the data across an HTTPS, instead of HTTP.
If you use this parameter, but SSL is not available on the port used for the command, the command fails.

.Example
PS C:\> Get-MachineCertificateThumbprint -Computername CHI-CORE02 | format-list


Computername : CHI-CORE02
Subject      : CN=CHI-CORE02.GLOBOMANTICS.local
Thumbprint   : 8197F97FB76A3392E6BD3959EB3B32103F0A299B
Verified     : True

.Example
PS C:\> $cert = Get-MachineCertificateThumbprint -Computername chi-fp02 -Credential globomantics\administrator

This command gets the certificate from CHI-FP02 using alternate credentials.

PS C:\> $cert.thumbprint
5984D285710937FE2982F9972498B84B8E4AFB56

Getting the certificate thumbprint
.Link
Test-Certificate

#>

[cmdletbinding()]
Param(
[Parameter(Position=0,ValueFromPipeline,ValueFromPipelineByPropertyName)]
[ValidateNotNullorEmpty()]
[Alias("cn")]
[string[]]$Computername = $env:COMPUTERNAME,
[Alias("RunAs")]
[PSCredential]
[System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty,
[ValidateRange(1, 65535)]
[int]$Port,
[switch]$UseSSL,
[System.Management.Automation.Runspaces.AuthenticationMechanism]$Authentication,
[string]$CertificateThumbprint
)

Begin {
    Write-Verbose "Starting: $($MyInvocation.Mycommand)"  
    #define a scriptblock to get certificates with Invoke-Command
    $get = {
     #get server authentication certs that have not expired
     #and get newest one
     Get-Childitem -path Cert:\LocalMachine\My | 
     Where-Object {$_.EnhancedKeyUsageList.FriendlyName -contains "Server Authentication" -AND $_.notAfter -gt (Get-Date) } |
     Sort-Object NotBefore -Descending | Select-Object -first 1
    }

    #remove Path from PSBoundparameters which can then be splatted to Invoke-Command
    $PSBoundParameters.Remove("Path") | Out-Null

    #add ErrorAction
    $PSBoundParameters.Add("ErrorAction","Stop")

    #add scriptblock
    $PSBoundParameters.Add("Scriptblock",$get)

    Write-Verbose "PSBoundParameters `n $(($PSBoundParameters | Out-String).Trim())"

} #begin

Process {

foreach ($computer in $Computername) {
    $PSBoundParameters.Computername = $Computer
    Try {
        #assumes a single certificate so sort on NotAfter
        Write-Verbose "Querying $computer for Machine certificates"
        $cert = Invoke-Command @PSBoundParameters
        Write-Verbose ($cert | Out-String).Trim()
    }
    Catch {
        Throw $_
    }

    if ($cert) {
        #create a custom object and export the certificate
        [pscustomobject]@{
         Computername = $cert.pscomputername
         Subject = $cert.Subject
         Thumbprint = $cert.Thumbprint
         Verified = Test-Certificate $cert 
        }
    
        } #if $cert
    else {
        Write-Warning "Failed to find a certificate for $($computer.toUpper())"
     }
   
} #foreach computer

} #process

End {
    Write-Verbose "Ending: $($MyInvocation.Mycommand)"
} #end

} #Get-MachineCertificateThumbprint

Set-Alias -Name emc -Value Export-MachineCertificate
Set-Alias -Name gct -Value Get-MachineCertificateThumbprint

Export-ModuleMember -Alias gmc,gct -Function Export-MachineCertificate,Get-MachineCertificateThumbprint